from dataclasses import dataclass
from typing import Callable, Optional

import numpy as np
import pandas as pd

from infsim.utils.context_sampler import ContextSampler


def get_price_from_uniform_random_context(item_context: pd.DataFrame) -> pd.Series:
    if "price" in item_context.columns:
        price = item_context.price
    else:
        price = 20 + item_context["item_feat_1"] * 100
    return price


def get_commission_percentage_from_uniform_random_context(
    item_context: pd.DataFrame,
) -> pd.Series:
    if "commission_percentage" in item_context.columns:
        commission_percentage = item_context.commission_percentage
    else:
        commission_percentage = 10 + item_context["item_feat_2"] * 5
    return commission_percentage


@dataclass
class PolicyLogs:
    """
    Stores logs generated by simulation environments. Using the PolicyLogs object, we can add readable context such
    as price and commission percentage as attributes. Any columns in the user_context and item_context prefixed
    with `_` represent values used for simulating outcomes, and should only be used for ground truth estimation.
    """

    user_context: pd.DataFrame
    item_context: pd.DataFrame
    discount_percentage: Optional[float] = None

    @property
    def price(self) -> pd.Series:
        return get_price_from_uniform_random_context(self.item_context)

    @property
    def commission_percentage(self) -> pd.Series:
        return get_commission_percentage_from_uniform_random_context(self.item_context)

    @property
    def profit(self) -> pd.Series:
        """
        Compute the observed profit from logs based on the observed conversions.
        """
        return (
            self.price
            * (
                self.commission_percentage / 100
                - (self.item_context.is_treated * self.discount_percentage)
            )
            * (self.item_context.is_converted)
        )

    @property
    def expected_profit(self) -> pd.Series:
        """
        Compute the expected profit from logs based on the (hidden) conversion probabilities.
        """
        item_context_with_user_conversion = pd.merge(
            self.item_context,
            self.user_context[["user_id", "_conversion_probability"]],
            on="user_id",
            how="left",
        )

        return (
            self.price
            * (
                self.commission_percentage / 100
                - (self.item_context.is_treated * self.discount_percentage)
            )
            * (
                self.item_context._relative_attractiveness
                * item_context_with_user_conversion._conversion_probability
            )
        )


@dataclass
class BaseEnvironment:
    """
    The core of the simulator is the Base Environment. The environment can be configured with various attributes to
    simulate different scenarios.

    context_sampler: A class containing a `sample` method that can be called to sample context for both users and items.
        A context sampler could also load external data.
    attractiveness_function: A method that transforms user and item context into attractiveness and
        attractiveness delta (treatment) scores.
    policy: A method that transforms user and item context into policy scores for data collection or evaluation.
    conversion_sampler: A method that transforms attractiveness scores into user and item conversion probabilities and
        samples based on these probabilities.
    seed: Random seed for reproducibility.
    discount_percentage: Number between 0 and 1 representing the percentage of discount provided when applying a treatment.
    """

    context_sampler: ContextSampler
    attractiveness_function: Callable
    policy: Callable
    conversion_sampler: Callable
    seed: Optional[int] = None
    discount_percentage: float = 0.08

    def __post_init__(self):
        if (
            hasattr(self.context_sampler, "seed")
            and self.seed == self.context_sampler.seed
        ):
            raise RuntimeError(
                "Context sampler and base environment cannot have the same seed. This can cause"
                "unexpected behaviour, which breaks randomisation."
            )
        self.rng = np.random.default_rng(self.seed)

    def step(self, n_samples: int) -> PolicyLogs:
        """
        Sample `n_samples` from the environment into a logs dataclass. This method can be used to create a set of logs
        that can be used for evaluation. For comparing various policies on the same environment, another policy can be
        called on the same logs using `resample_with_alternative_policy`.
        """
        user_context, item_context = self.context_sampler.sample(n_samples)
        user_context, item_context = self.policy(
            user_context, item_context, rng=self.rng
        )
        item_context = self.attractiveness_function(
            user_context,
            item_context,
            discount_percentage=self.discount_percentage,
            seed=self.seed,
        )
        user_context, item_context = self.conversion_sampler(
            user_context, item_context, rng=self.rng
        )

        return PolicyLogs(
            user_context=user_context,
            item_context=item_context,
            discount_percentage=self.discount_percentage,
        )

    def resample_with_alternative_policy(
        self,
        logs: PolicyLogs,
        policy: Optional[Callable] = None,
        treatment: Optional[np.array] = None,
    ) -> PolicyLogs:
        """
        Allows recomputing the attractiveness, conversions (including underlying probabilities) for a different policy
        on existing logs. Can be used to compare the true performance of multiple policies on the same environment.

        Either a policy or treatment vector should be provided

        logs: Existing logs generated by a simulated environment. Logs have to generated with the same base environment
        policy: A method that transforms user and item context into policy scores for data collection or evaluation.
        treatment: A vector of the same size as logs.item_context containing 1's and 0's for treatments and no treatments respectively.
        """
        user_context = logs.user_context.copy()
        del user_context["_conversion_probability"]
        item_context = logs.item_context.copy()
        del item_context["model_score"]
        del item_context["is_treated"]

        if policy is None and treatment is None:
            raise RuntimeError(
                "Either policy or treatment should be provided in order to resample."
            )

        if policy is not None and treatment is not None:
            raise RuntimeError(
                "Both policy and treatment were provided, please either provide a policy or specify"
                " treatment."
            )

        if treatment is not None:
            if len(treatment) != len(logs.item_context.is_treated):
                raise RuntimeError(
                    f"Treatment is of incorrect size, expecting {len(logs.item_context.is_treated)},"
                    f" but got {len(treatment)}"
                )
            item_context["model_score"] = None
            item_context["is_treated"] = treatment
        elif policy is not None:
            user_context, item_context = policy(
                user_context, item_context, rng=self.rng
            )

        # A bit of code duplication for huge efficiency gains...
        item_context["_treatment_attractiveness"] = (
            item_context._base_attractiveness
            + (
                item_context.is_treated
                * logs.discount_percentage
                * 10
                * item_context._treatment_attractiveness_delta
            )
        )

        user_context, item_context = self.conversion_sampler(
            user_context, item_context, rng=self.rng
        )

        return PolicyLogs(
            user_context=user_context,
            item_context=item_context,
            discount_percentage=logs.discount_percentage,
        )
